<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.js webgl - geometry - extrude shapes</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    html, body {
      overflow: hidden;
    }
    body {
      position: relative;
      font-family: Monospace;
      background-color: #000;
      margin: 0px;
    }
    a {
      color: skyblue;
    }
</style>
</head>

<body>

  <script src="./lib/three.js"></script>

  <script src="./lib/exporters/STLExporter.js" ></script>
  <script src="./lib/loaders/SVGLoader.js"></script>
  <script src="./lib/postprocessing/EffectComposer.js"></script>
  <script src="./lib/postprocessing/RenderPass.js"></script>
  <script src="./lib/postprocessing/ShaderPass.js"></script>
  <script src="./lib/postprocessing/UnrealBloomPass.js"></script>
  <script src="./lib/shaders/CopyShader.js"></script>
  <script src="./lib/shaders/LuminosityHighPassShader.js"></script>
  <script src="./lib/utils/BufferGeometryUtils.js"></script>

  <script src="./js/EllipseCurve3D.js"></script>
  <script src="./js/InTheMoodToExtrude.js"></script>
  <script src="./js/Logoform.js"></script>
  <script src="./js/HalftonePass.js"></script>

  <script>

    const linkWhole = document.createElement( 'a' );
    linkWhole.text = "Download STL (Whole)";
    linkWhole.style.display = 'none';
    document.body.appendChild( linkWhole );

    const linkApart = document.createElement( 'a' );
    linkApart.text = "Download STL (Apart)";
    linkApart.style.display = 'none';
    document.body.appendChild( linkApart );

    const renderer = new THREE.WebGLRenderer();
    renderer.setClearColor( 0x000000, 0 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    const scene = new THREE.Scene();

    const cameraCloseness = 200;
    const perspectiveCamera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
    const orthographicCamera = new THREE.OrthographicCamera( window.innerWidth / - cameraCloseness, window.innerWidth / cameraCloseness, window.innerHeight / cameraCloseness, window.innerHeight / -cameraCloseness, - 500, 1000);
    [perspectiveCamera, orthographicCamera].forEach(camera => {
      camera.position.set(0, 0, 2000 / cameraCloseness );
      scene.add(camera);
    });
    let camera = perspectiveCamera;

    const lights = new THREE.Group();
    scene.add(lights);

    const addLight = (x, y, z) => {
      const light = new THREE.PointLight( 0xffffff );
      light.decay = 2;
      light.intensity = 0.4;
      light.position.set(x, y, z);
      lights.add( light );
    };

    // scene.add(new THREE.AmbientLight(0xff0000, 0.05 ));

    addLight(-10, 10, 10);
    addLight(10, 10, 10);

    const group = new THREE.Group();
    scene.add(group);

    const model = new THREE.Group();
    group.add(model);
    const laidOutModel = new THREE.Group();
    group.add(laidOutModel);
    laidOutModel.visible = false;

    const logoformUnions = makeLogoform().map(geoms => THREE.BufferGeometryUtils.mergeBufferGeometries(geoms));

    const pieceTransforms = [
      {
        color: 0xFFFFFF,
        position: new THREE.Vector3(5, Math.SQRT1_2 * -4.8 + 0.5, 0),
        rotation: new THREE.Euler(Math.PI * 0, Math.PI * 0, Math.PI * 1.5),
      },
      {
        color: 0xFF0000,
        position: new THREE.Vector3(2, Math.SQRT1_2 * -4.8 + 0.5, -3),
        rotation: new THREE.Euler(Math.PI * 0, Math.PI * 1, Math.PI * 0.5),
      },
      {
        color: 0xFFFF00,
        position: new THREE.Vector3(0, Math.SQRT1_2 * -3 + 0.5, 0.5),
        rotation: new THREE.Euler(Math.PI * 0, Math.PI * 2, Math.PI * 0),
      },
      {
        color: 0x00FF00,
        position: new THREE.Vector3(-1, -0.5, -3),
        rotation: new THREE.Euler(Math.PI * 0.5, Math.PI * 0, Math.PI * 0),
      },
      {
        color: 0x00FFFF,
        position: new THREE.Vector3(0.25, Math.SQRT1_2 * -0.25 + 0.5, -1.5),
        rotation: new THREE.Euler(Math.PI * 0, Math.PI * 0.5, Math.PI * 0),
      },
      {
        color: 0x0000FF,
        position: new THREE.Vector3(-1, -0.5, 1),
        rotation: new THREE.Euler(Math.PI * 1.5, Math.PI * 0, Math.PI * 0),
      },
      {
        color: 0xFF00FF,
        position: new THREE.Vector3(1, -0.5, 2),
        rotation: new THREE.Euler(Math.PI * 0.5, Math.PI * 0, Math.PI * 0),
      },
    ];

    const modelMaterial = new THREE.MeshPhysicalMaterial({color: 0xFFFFFF, roughness: 0.5, metalness: 0, reflectivity: 0, emissive: 0x0});

    const laidOutGeometries = logoformUnions.map((geom, i) => {

      model.add(new THREE.Mesh(geom, modelMaterial));

      const pieceTransform = pieceTransforms[i];
      const matrix = new THREE.Matrix4();
      matrix.makeRotationFromEuler(pieceTransform.rotation);
      matrix.setPosition(pieceTransform.position);
      const laidOutGeom = geom.clone();
      laidOutGeom.applyMatrix(matrix);

      const material =
      new THREE.MeshBasicMaterial({color: pieceTransforms[i].color, wireframe: true});
      // new THREE.MeshPhysicalMaterial({color: pieceTransforms[i].color, roughness: 0.5, metalness: 0, reflectivity: 0, emissive: 0x0});

      laidOutModel.add(new THREE.Mesh(laidOutGeom, material))

      return laidOutGeom;
    });

    const mergedGeom = THREE.BufferGeometryUtils.mergeBufferGeometries(laidOutGeometries);
    const laidOutMesh = new THREE.Mesh(
      mergedGeom,
      new THREE.MeshPhysicalMaterial({color:0xFFFFFF, roughness: 0.5, metalness: 0, reflectivity: 0, emissive: 0x0})
    );

    const stlWhole = (new THREE.STLExporter()).parse(model, { binary: true });
    linkWhole.href = URL.createObjectURL(new Blob( [ stlWhole ], { type: 'application/octet-stream' } ));
    linkWhole.download = 'rm_whole.stl';
    linkWhole.style.display = 'unset';

    const stlApart = (new THREE.STLExporter()).parse(laidOutMesh, { binary: true });
    linkApart.href = URL.createObjectURL(new Blob( [ stlApart ], { type: 'application/octet-stream' } ));
    linkApart.download = 'rm_apart.stl';
    linkApart.style.display = 'unset';


    /*
    (new THREE.SVGLoader()).load('rm.svg', paths => {
      const svgGroup = new THREE.Group();
      paths.map(path => path.toShapes(true)).forEach(
        shapes => shapes.forEach(
          shape => svgGroup.add(
            new THREE.Mesh(
              new THREE.ShapeBufferGeometry( shape ),
              new THREE.MeshBasicMaterial({color: 0xFF0000, transparent:true, opacity: 0.5, side: THREE.DoubleSide})
              )
            )
          )
        );
      const scale = 0.01 / Math.SQRT1_2;
      svgGroup.scale.set(scale, -scale, scale);
      svgGroup.position.set(-240 * scale, 150 * scale, 0 * scale);
      // group.add( svgGroup );
    });
    */

    const composer = new THREE.EffectComposer( renderer );
    const renderPass = new THREE.RenderPass( scene, camera );
    composer.addPass( renderPass );

    const halftonePass = new THREE.HalftonePass(0x220000, 0xFFFFD8, Math.pow(2, -4.65), 30, 0.7);
    composer.addPass( halftonePass );

    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2( window.innerWidth, window.innerHeight ), 0.5, 1.5, 0
    );
    composer.addPass( bloomPass );

    const resize = () => {
      renderer.setSize( window.innerWidth, window.innerHeight );
      composer.setSize( window.innerWidth, window.innerHeight );

      perspectiveCamera.aspect = window.innerWidth / window.innerHeight;
      perspectiveCamera.updateProjectionMatrix();
      orthographicCamera.left = -window.innerWidth / cameraCloseness;
      orthographicCamera.right = window.innerWidth / cameraCloseness;
      orthographicCamera.top = window.innerHeight / cameraCloseness;
      orthographicCamera.bottom = -window.innerHeight / cameraCloseness;
      orthographicCamera.updateProjectionMatrix();

      halftonePass.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener("resize", resize);
    resize();
    composer.passes[composer.passes.length - 1].renderToScreen = true;

    let [mouseX, mouseY] = [0, 0];
    const pan = ({screenX, screenY}) => [mouseX, mouseY] = [screenX / window.innerWidth - 0.5, screenY / window.innerHeight - 0.5];
    window.addEventListener("mousemove", pan);
    window.addEventListener("touchmove", ({touches}) => pan(touches[0]));
    window.addEventListener("click", () => {
      camera = (camera == perspectiveCamera) ? orthographicCamera : perspectiveCamera;
      renderPass.camera = camera;
    });

    function redraw() {
      requestAnimationFrame( redraw );
      group.rotation.set(mouseY * 8, mouseX * 8, 0);
      composer.render( 0 );
    }
    redraw();

    let mode = 0;
    const setMode = value => {
      mode = value;
      switch (mode) {
        case 0:
          model.visible = true;
          laidOutModel.visible = false;
          composer.passes[composer.passes.length - 1].renderToScreen = true;
          renderPass.renderToScreen = false;
        break;
        case 1:
          model.visible = true;
          laidOutModel.visible = false;
          composer.passes[composer.passes.length - 1].renderToScreen = false;
          renderPass.renderToScreen = true;
        break;
        case 2:
          model.visible = false;
          laidOutModel.visible = true;
          composer.passes[composer.passes.length - 1].renderToScreen = false;
          renderPass.renderToScreen = true;
        break;
      }
    };
    setMode(0);
    document.addEventListener("keydown", () => setMode((mode + 1) % 3));

  </script>

</body>

</html>
